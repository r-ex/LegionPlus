#pragma once
#include <cstdint>
#include <Vector3.h>
#include <Quaternion.h>
#include <corecrt_math.h>
#include <Vector2.h>
#include "ListBase.h"
#include "StringBase.h"

typedef unsigned short uint16;

// This flag is set if no hitbox information was specified
#define STUDIOHDR_FLAGS_AUTOGENERATED_HITBOX	0x1

// NOTE:  This flag is set at loadtime, not mdl build time so that we don't have to rebuild
// models when we change materials.
#define STUDIOHDR_FLAGS_USES_ENV_CUBEMAP		0x2

// Use this when there are translucent parts to the model but we're not going to sort it 
#define STUDIOHDR_FLAGS_FORCE_OPAQUE			0x4

// Use this when we want to render the opaque parts during the opaque pass
// and the translucent parts during the translucent pass
#define STUDIOHDR_FLAGS_TRANSLUCENT_TWOPASS		0x8

// This is set any time the .qc files has $staticprop in it
// Means there's no bones and no transforms
#define STUDIOHDR_FLAGS_STATIC_PROP				0x10

// NOTE:  This flag is set at loadtime, not mdl build time so that we don't have to rebuild
// models when we change materials.
#define STUDIOHDR_FLAGS_USES_FB_TEXTURE		    0x20

// This flag is set by studiomdl.exe if a separate "$shadowlod" entry was present
//  for the .mdl (the shadow lod is the last entry in the lod list if present)
#define STUDIOHDR_FLAGS_HASSHADOWLOD			0x40

// NOTE:  This flag is set at loadtime, not mdl build time so that we don't have to rebuild
// models when we change materials.
#define STUDIOHDR_FLAGS_USES_BUMPMAPPING		0x80

// NOTE:  This flag is set when we should use the actual materials on the shadow LOD
// instead of overriding them with the default one (necessary for translucent shadows)
#define STUDIOHDR_FLAGS_USE_SHADOWLOD_MATERIALS	0x100

// NOTE:  This flag is set when we should use the actual materials on the shadow LOD
// instead of overriding them with the default one (necessary for translucent shadows)
#define STUDIOHDR_FLAGS_OBSOLETE				0x200

#define STUDIOHDR_FLAGS_UNUSED					0x400

// NOTE:  This flag is set at mdl build time
#define STUDIOHDR_FLAGS_NO_FORCED_FADE			0x800

// NOTE:  The npc will lengthen the viseme check to always include two phonemes
#define STUDIOHDR_FLAGS_FORCE_PHONEME_CROSSFADE	0x1000

// This flag is set when the .qc has $constantdirectionallight in it
// If set, we use constantdirectionallightdot to calculate light intensity
// rather than the normal directional dot product
// only valid if STUDIOHDR_FLAGS_STATIC_PROP is also set
#define STUDIOHDR_FLAGS_CONSTANT_DIRECTIONAL_LIGHT_DOT 0x2000

// Flag to mark delta flexes as already converted from disk format to memory format
// in v54+ this has to do with Funny Weights I think
//STUDIOHDR_FLAGS_COMPLEX_WEIGHTS
#define STUDIOHDR_FLAGS_FLEXES_CONVERTED		0x4000

// Indicates the studiomdl was built in preview mode
#define STUDIOHDR_FLAGS_BUILT_IN_PREVIEW_MODE	0x8000

// Ambient boost (runtime flag)
#define STUDIOHDR_FLAGS_AMBIENT_BOOST			0x10000

// Don't cast shadows from this model (useful on first-person models)
#define STUDIOHDR_FLAGS_DO_NOT_CAST_SHADOWS		0x20000

// alpha textures should cast shadows in vrad on this model (ONLY prop_static!)
#define STUDIOHDR_FLAGS_CAST_TEXTURE_SHADOWS	0x40000

// Model has a quad-only Catmull-Clark SubD cage
#define STUDIOHDR_FLAGS_SUBDIVISION_SURFACE		0x80000

// flagged on load to indicate no animation events on this model
#define STUDIOHDR_FLAGS_NO_ANIM_EVENTS			0x100000

// If flag is set then studiohdr_t.flVertAnimFixedPointScale contains the
// scale value for fixed point vert anim data, if not set then the
// scale value is the default of 1.0 / 4096.0.  Regardless use
// studiohdr_t::VertAnimFixedPointScale() to always retrieve the scale value
#define STUDIOHDR_FLAGS_VERT_ANIM_FIXED_POINT_SCALE	0x200000


#define FIX_OFFSET(offset) ((offset & 0xFFFE) << (4 * (offset & 1)))

#pragma pack(push, 1)
struct matrix3x4_t
{
	// unsure if that's how it actually works

	// row 1, x
	float c0r0; // x
	float c1r0; // x
	float c2r0; // x
	float c3r0; // x

	// row 2, y
	float c0r1; // y
	float c1r1; // y
	float c2r1; // y
	float c3r1; // y

	// row 3, z
	float c0r2; // z
	float c1r2; // z
	float c2r2; // z
	float c3r2; // z

	Vector3 GetRotationMatrixAsDegrees()
	{
		// c0r0, c1r0, c2r0, c0r1, c1r1, c2r1, c2r2
		float x, y, z, tX, tY;

		float m2 = c2r0;
		if (m2 < -1)
			m2 = -1;
		else if (m2 > 1)
			m2 = 1;

		y = -asin(m2);

		printf("%f\n", m2);

		float cosY = cos(y);

		y = Math::MathHelper::RadiansToDegrees(y);

		if (abs(cosY) > 0.005)
		{
			tX = c2r2 / cosY;
			tY = -c2r1 / cosY;
			x = Math::MathHelper::RadiansToDegrees(atan2(tY, tX));

			tX = c0r0 / cosY;
			tY = -c1r0 / cosY;
			z = Math::MathHelper::RadiansToDegrees(atan2(tY, tX));
		}
		else
		{
			x = 0;
			tX = c1r1 / cosY;
			tY = c0r1 / cosY;
			z = Math::MathHelper::RadiansToDegrees(atan2(tY, tX));
		}


		// these can take some strange orders and idrk how to determine it
		//if (m2 == 0)
		//{
		//	return { x,z,y };
		//}
		//else if (m2 < 1 && m2 != -1)
		//{
		//	return { z,y,x };
		//}

		return { x,y,z };
	}
};


struct s3studiohdr_t // season 3 studiohdr
{
	int id; // Model format ID, such as "IDST" (0x49 0x44 0x53 0x54)
	int version; // Format version number, such as 48 (0x30,0x00,0x00,0x00)
	int checksum; // This has to be the same in the phy and vtx files to load!
	int sznameindex; // This has been moved from studiohdr2 to the front of the main header.
	char name[64]; // The internal name of the model, padding with null bytes.
	// Typically "my_model.mdl" will have an internal name of "my_model"
	int length; // Data size of MDL file in bytes.

	Vector3 eyeposition;	// ideal eye position

	Vector3 illumposition;	// illumination center

	Vector3 hull_min;		// ideal movement hull size
	Vector3 hull_max;

	Vector3 view_bbmin;		// clipping bounding box
	Vector3 view_bbmax;

	int flags;

	int numbones; // bones
	int boneindex;

	int numbonecontrollers; // bone controllers
	int bonecontrollerindex;

	int numhitboxsets;
	int hitboxsetindex;

	int numlocalanim; // animations/poses
	int localanimindex; // animation descriptions

	int numlocalseq; // sequences
	int	localseqindex;

	int activitylistversion; // initialization flag - have the sequences been indexed?

	// mstudiotexture_t
	// short rpak path
	// raw textures
	int materialtypesindex;
	int numtextures; // the material limit exceeds 128, probably 256.
	int textureindex;

	// this should always only be one, unless using vmts.
	// raw textures search paths
	int numcdtextures;
	int cdtextureindex;

	// replaceable textures tables
	int numskinref;
	int numskinfamilies;
	int skinindex;

	int numbodyparts;
	int bodypartindex;

	int numlocalattachments;
	int localattachmentindex;

	int numlocalnodes;
	int localnodeindex;
	int localnodenameindex;

	int numunknodes;
	int unknodexindex;

	int meshindex; // SubmeshLodsOffset, might just be a mess offset

	int deprecated_numflexcontrollers;
	int deprecated_flexcontrollerindex;

	int deprecated_numflexrules;
	int deprecated_flexruleindex;

	int numikchains;
	int ikchainindex;

	// this is rui meshes
	int numruimeshes;
	int ruimeshindex;

	int numlocalposeparameters;
	int localposeparamindex;

	int surfacepropindex;

	int keyvalueindex;
	int keyvaluesize;

	int numlocalikautoplaylocks;
	int localikautoplaylockindex;

	float mass;
	int contents;

	// unused for packed models
	int numincludemodels;
	int includemodelindex;

	uint32_t virtualModel;

	int bonetablebynameindex;

	// if STUDIOHDR_FLAGS_CONSTANT_DIRECTIONAL_LIGHT_DOT is set,
	// this value is used to calculate directional components of lighting 
	// on static props
	byte constdirectionallightdot;

	// set during load of mdl data to track *desired* lod configuration (not actual)
	// the *actual* clamped root lod is found in studiohwdata
	// this is stored here as a global store to ensure the staged loading matches the rendering
	byte rootLOD;

	// set in the mdl data to specify that lod configuration should only allow first numAllowRootLODs
	// to be set as root LOD:
	//	numAllowedRootLODs = 0	means no restriction, any lod can be set as root lod.
	//	numAllowedRootLODs = N	means that lod0 - lod(N-1) can be set as root lod, but not lodN or lower.
	byte numAllowedRootLODs;

	byte unused;

	float fadeDistance;

	float gathersize; // what. from r5r struct

	int numunk_v54_early;
	int unkindex_v54_early;

	float flVertAnimFixedPointScale; // to be verified
	int surfacepropLookup; // saved in the file

	int sourceFilenameOffset;

	int numsrcbonetransform;
	int srcbonetransformindex;

	int	illumpositionattachmentindex;

	int linearboneindex;

	int m_nBoneFlexDriverCount; // unsure if that's what it is in apex
	int m_nBoneFlexDriverIndex;

	int unkindexflex;

	int unk1_v54[6];

	// always "" or "Titan"
	int unkstringindex;

	// this is now used for combined files in rpak, vtx, vvd, and vvc are all combined while vphy is separate.
	// the indexes are added to the offset in the rpak mdl_ header.
	// vphy isn't vphy, looks like a heavily modified vphy.
	int vtxindex; // VTX
	int vvdindex; // VVD / IDSV
	int vvcindex; // VVC / IDCV 
	int vphyindex; // VPHY / IVPS

	int vtxsize;
	int vvdsize;
	int vvcsize;
	int vphysize; // still used in models using vg

	// unused in apex
	int unkmemberindex1;
	int numunkmember1;

	// only seen on '_animated' suffixed models so far
	int unkcount3;
	int unkindex3;

	// Per Tri Collision AABB size
	Vector3 mins;
	Vector3 maxs; // seem to be the same as hull size

	int unk3_v54[3];

	int unkindex4; // chunk before unkindex3 sometimes

	short unk4_v54[2]; // same as unk3_v54_v121

	int weightindex;
	int weightsize;

	//int vgindex; // 0tVG
	//int unksize; // might be offset
	//int unksize1; // might be offset


};

struct r2studiohdr_t // titanfall 2 studiohdr (MDL v53)
{
	int id; // Model format ID, such as "IDST" (0x49 0x44 0x53 0x54)
	int version; // Format version number, such as 48 (0x30,0x00,0x00,0x00)
	int checksum; // This has to be the same in the phy and vtx files to load!
	int sznameindex; // This has been moved from studiohdr2 to the front of the main header.
	char name[64]; // The internal name of the model, padding with null bytes.
	// Typically "my_model.mdl" will have an internal name of "my_model"
	int length; // Data size of MDL file in bytes.

	Vector3 eyeposition;	// ideal eye position

	Vector3 illumposition;	// illumination center

	Vector3 hull_min;		// ideal movement hull size
	Vector3 hull_max;

	Vector3 view_bbmin;		// clipping bounding box
	Vector3 view_bbmax;

	int flags;

	int numbones; // bones
	int boneindex;

	int numbonecontrollers; // bone controllers
	int bonecontrollerindex;

	int numhitboxsets;
	int hitboxsetindex;

	int numlocalanim; // animations/poses
	int localanimindex; // animation descriptions

	int numlocalseq; // sequences
	int localseqindex;

	int activitylistversion; // initialization flag - have the sequences been indexed?
	int eventsindexed;

	// mstudiotexture_t
	// short rpak path
	// raw textures
	int numtextures; // the material limit exceeds 128, probably 256.
	int textureindex;

	// this should always only be one, unless using vmts.
	// raw textures search paths
	int numcdtextures;
	int cdtextureindex;

	// replaceable textures tables
	int numskinref;
	int numskinfamilies;
	int skinindex;

	int numbodyparts;
	int bodypartindex;

	int numlocalattachments;
	int localattachmentindex;

	int numlocalnodes;
	int localnodeindex;
	int localnodenameindex;

	int numflexdesc;
	int flexdescindex;

	int numflexcontrollers;
	int flexcontrollerindex;

	int numflexrules;
	int flexruleindex;

	int numikchains;
	int ikchainindex;

	// this is rui meshes, todo refind mouth count.
	int numruimeshes;
	int ruimeshindex;

	int numlocalposeparameters;
	int localposeparamindex;

	int surfacepropindex;

	int keyvalueindex;
	int keyvaluesize;

	int numlocalikautoplaylocks;
	int localikautoplaylockindex;

	float mass;
	int contents;

	// external animations, models, etc.
	int numincludemodels;
	int includemodelindex;

	uint32_t virtualModel;

	// animblock is either completely cut, this is because they no longer use .ani files.

	int bonetablebynameindex;

	// if STUDIOHDR_FLAGS_CONSTANT_DIRECTIONAL_LIGHT_DOT is set,
	// this value is used to calculate directional components of lighting 
	// on static props
	byte constdirectionallightdot;

	// set during load of mdl data to track *desired* lod configuration (not actual)
	// the *actual* clamped root lod is found in studiohwdata
	// this is stored here as a global store to ensure the staged loading matches the rendering
	byte rootLOD;

	// set in the mdl data to specify that lod configuration should only allow first numAllowRootLODs
	// to be set as root LOD:
	//	numAllowedRootLODs = 0	means no restriction, any lod can be set as root lod.
	//	numAllowedRootLODs = N	means that lod0 - lod(N-1) can be set as root lod, but not lodN or lower.
	byte numAllowedRootLODs;

	byte unused;

	float fadedistance; // set to -1 to never fade. set above 0 if you want it to fade out, distance is in feet.
	// player/titan models seem to inherit this value from the first model loaded in menus.
	// works oddly on entities, probably only meant for static props

	int numflexcontrollerui;
	int flexcontrolleruiindex;

	// used by tools only that don't cache, but persist mdl's peer data
	// engine uses virtualModel to back link to cache pointers
	// might not be correct
	uint32_t pVertexBase; // float flVertAnimFixedPointScale;
	uint32_t pIndexBase; // int surfacepropLookup;

	// this is in all shipped models, probably part of their asset bakery. it should be 0x2CC.
	// doesn't actually need to be written pretty sure, only four bytes when not present.
	// this is not completely true as some models simply have nothing, such as animation models.
	int mayaindex;

	int numsrcbonetransform;
	int srcbonetransformindex;

	int illumpositionattachmentindex;

	int linearboneindex;

	int m_nBoneFlexDriverCount;
	int m_nBoneFlexDriverIndex;

	// for static props (and maybe others)
	// Per Triangle AABB
	int aabbindex;
	int numaabb;
	int numaabb1;
	int numaabb2;

	int stringtableindex;

	// start of model combination stuff.
	// anis are no longer used from what I can tell, v52s that had them don't in v53.
	int vtxindex; // VTX
	int vvdindex; // VVD / IDSV
	int vvcindex; // VVC / IDCV 
	int vphyindex; // VPHY / IVPS

	int vtxsize;
	int vvdsize;
	int vvcsize;
	int vphysize;

	// the following 'unks' could actually be indexs.
	// one of these is probably the ANI/IDAG index
	// vertAnimFixedPointScale might be in here but I doubt it.

	// this data block is related to the vphy, if it's not present the data will not be written
	int unkmemberindex1; // section between vphy and vtx.?
	int numunkmember1; // only seems to be used when phy has one solid

	int unk;

	int unkindex3; // goes to the same spot as vtx normally.

	int unused1[60]; // god I hope
};

struct studiohdr_t_v121
{
	int id; // Model format ID, such as "IDST" (0x49 0x44 0x53 0x54)
	int version; // Format version number, such as 48 (0x30,0x00,0x00,0x00)
	int checksum; // This has to be the same in the phy and vtx files to load!
	int sznameindex; // This has been moved from studiohdr2 to the front of the main header.
	char name[64]; // The internal name of the model, padding with null bytes.
	// Typically "my_model.mdl" will have an internal name of "my_model"
	int length; // Data size of MDL file in bytes.

	Vector3 eyeposition;	// ideal eye position

	Vector3 illumposition;	// illumination center

	Vector3 hull_min;		// ideal movement hull size
	Vector3 hull_max;

	Vector3 view_bbmin;		// clipping bounding box
	Vector3 view_bbmax;

	int flags;

	int numbones; // bones
	int boneindex;

	int numbonecontrollers; // bone controllers
	int bonecontrollerindex;

	int numhitboxsets;
	int hitboxsetindex;

	// unused now
	int numlocalanim; // animations/poses
	int localanimindex; // animation descriptions

	int numlocalseq; // sequences
	int	localseqindex;

	int activitylistversion; // initialization flag - have the sequences been indexed?

	// mstudiotexture_t
	// short rpak path
	// raw textures
	int materialtypesindex;
	int numtextures; // the material limit exceeds 128, probably 256.
	int textureindex;

	// this should always only be one, unless using vmts.
	// raw textures search paths
	int numcdtextures;
	int cdtextureindex;

	// replaceable textures tables
	int numskinref;
	int numskinfamilies;
	int skinindex;

	int numbodyparts;
	int bodypartindex;

	int numlocalattachments;
	int localattachmentindex;

	int numlocalnodes;
	int localnodeindex;
	int localnodenameindex;

	int numunknodes;
	int nodedataindexindex;

	int numikchains;
	int ikchainindex;

	// this is rui meshes
	int numruimeshes;
	int ruimeshindex;

	int numlocalposeparameters;
	int localposeparamindex;

	int surfacepropindex;

	int keyvalueindex;
	int keyvaluesize;

	int numlocalikautoplaylocks;
	int localikautoplaylockindex;

	float mass;
	int contents;

	// unused for packed models
	int numincludemodels;
	int includemodelindex;

	uint32_t virtualModel;

	int bonetablebynameindex;

	// stuff moved from vg in v12.1
	int numVGMeshes; // total number of meshes, not including LODs
	int vgMeshIndex;

	int boneStateIndex;
	int numBoneStates;

	int unk_v54_v121; // related to vg likely

	int vgSize;

	short vgUnk; // same as padding in vg header
	short vgLODCount; // same as lod count in vg header

	int vgNumUnknown; // same as unk1 in vg header

	int vgHeaderIndex;
	int numVGHeaders;

	int vgLODIndex;
	int numVGLODs;

	float fadeDistance;

	float gathersize; // what. from r5r struct

	float flVertAnimFixedPointScale; // to be verified
	int surfacepropLookup; // saved in the file

	// asset bakery strings if it has any
	int sourceFilenameOffset;

	int numsrcbonetransform;
	int srcbonetransformindex;

	int	illumpositionattachmentindex;

	int linearboneindex;

	// unsure what this is for but it exists for jigglbones
	int numprocbonesunk;
	int procbonearrayindex;
	int procbonemaskindex;

	// always "" or "Titan"
	int unkstringindex;

	// the indexes are added to the offset in the rpak mdl_ header.
	// vphy isn't vphy, looks like a heavily modified vphy.
	// something different about these now
	int vtxindex; // VTX
	int vvdindex; // VVD / IDSV
	int vvcindex; // VVC / IDCV 
	int vphyindex; // VPHY / IVPS

	int vtxsize;
	int vvdsize;
	int vvcsize;
	int vphysize;

	// only seen on '_animated' suffixed models so far
	int unkcount3;
	int unkindex3;

	// BVH4 size (?)
	Vector3 mins;
	Vector3 maxs; // seem to be the same as hull size

	int bvh4index; // bvh4 tree

	short unk4_v54[2]; // same as unk3_v54_v121, 2nd might be base for other offsets?

	int vvwindex;
	int vvwsize;

	inline s3studiohdr_t Downgrade()
	{
		s3studiohdr_t out{};
		out.flags = this->flags;
		out.surfacepropindex = this->surfacepropindex;
		out.contents = this->contents;
		out.eyeposition = this->eyeposition;
		out.illumposition = this->illumposition;
		out.numbones = this->numbones;
		out.boneindex = this->boneindex;
		out.numbodyparts = this->numbodyparts;
		out.bodypartindex = this->bodypartindex;
		out.numlocalattachments = this->numlocalattachments;
		out.localattachmentindex = this->localattachmentindex;
		out.numskinfamilies = this->numskinfamilies;
		out.skinindex = this->skinindex;
		out.numskinref = this->numskinref;
		out.numhitboxsets = this->numhitboxsets;
		out.hitboxsetindex = this->hitboxsetindex;
		out.textureindex = this->textureindex;
		out.numtextures = this->numtextures;
		out.ikchainindex = this->ikchainindex;
		out.ikchainindex = this->numikchains;
		out.localposeparamindex = this->localposeparamindex;
		out.numlocalposeparameters = this->numlocalposeparameters;
		out.keyvalueindex = this->keyvalueindex;
		return out;
	}
};

struct studiohdr_t_v122
{
	int id; // Model format ID, such as "IDST" (0x49 0x44 0x53 0x54)
	int version; // Format version number, such as 48 (0x30,0x00,0x00,0x00)
	int checksum; // This has to be the same in the phy and vtx files to load!
	int sznameindex; // This has been moved from studiohdr2 to the front of the main header.
	char name[64]; // The internal name of the model, padding with null bytes.
	// Typically "my_model.mdl" will have an internal name of "my_model"
	int length; // Data size of MDL file in bytes.

	Vector3 eyeposition;	// ideal eye position

	Vector3 illumposition;	// illumination center

	Vector3 hull_min;		// ideal movement hull size
	Vector3 hull_max;

	Vector3 view_bbmin;		// clipping bounding box
	Vector3 view_bbmax;

	int flags;

	int numbones; // bones
	int boneindex;

	int numbonecontrollers; // bone controllers
	int bonecontrollerindex;

	int numhitboxsets;
	int hitboxsetindex;

	// unused now
	int numlocalanim; // animations/poses
	int localanimindex; // animation descriptions

	int numlocalseq; // sequences
	int	localseqindex;

	int activitylistversion; // initialization flag - have the sequences been indexed?

	// mstudiotexture_t
	// short rpak path
	// raw textures
	int materialtypesindex;
	int numtextures; // the material limit exceeds 128, probably 256.
	int textureindex;

	// this should always only be one, unless using vmts.
	// raw textures search paths
	int numcdtextures;
	int cdtextureindex;

	// replaceable textures tables
	int numskinref;
	int numskinfamilies;
	int skinindex;

	int numbodyparts;
	int bodypartindex;

	int numlocalattachments;
	int localattachmentindex;

	int numlocalnodes;
	int localnodeindex;
	int localnodenameindex;

	int numunknodes;
	int nodedataindexindex;

	int numikchains;
	int ikchainindex;

	// this is rui meshes
	int numruimeshes;
	int ruimeshindex;

	int numlocalposeparameters;
	int localposeparamindex;

	int surfacepropindex;

	int keyvalueindex;
	int keyvaluesize;

	int numlocalikautoplaylocks;
	int localikautoplaylockindex;

	float mass;
	int contents;

	// unused for packed models
	int numincludemodels;
	int includemodelindex;

	uint32_t virtualModel;

	int bonetablebynameindex;

	// stuff moved from vg in v12.1
	int numVGMeshes; // total number of meshes, not including LODs
	int vgMeshIndex;

	int boneStateIndex;
	int numBoneStates;

	int unk_v54_v121; // related to vg likely

	int vgSize;

	short vgUnk; // same as padding in vg header
	short vgLODCount; // same as lod count in vg header

	int vgNumUnknown; // same as unk1 in vg header

	int vgHeaderIndex;
	int numVGHeaders;

	int vgLODIndex;
	int numVGLODs;

	float fadeDistance;

	float gathersize; // what. from r5r struct

	float flVertAnimFixedPointScale; // to be verified
	int surfacepropLookup; // saved in the file

	int unk_v54_v122; // added in transition version

	// asset bakery strings if it has any
	int sourceFilenameOffset;

	int numsrcbonetransform;
	int srcbonetransformindex;

	int	illumpositionattachmentindex;

	int linearboneindex;

	// unsure what this is for but it exists for jigglbones
	int numprocbonesunk;
	int procbonearrayindex;
	int procbonemaskindex;

	// always "" or "Titan"
	int unkstringindex;

	// the indexes are added to the offset in the rpak mdl_ header.
	// vphy isn't vphy, looks like a heavily modified vphy.
	// something different about these now
	int vtxindex; // VTX
	int vvdindex; // VVD / IDSV
	int vvcindex; // VVC / IDCV 
	int vphyindex; // VPHY / IVPS

	int vtxsize;
	int vvdsize;
	int vvcsize;
	int vphysize;

	// only seen on '_animated' suffixed models so far
	int unkcount3;
	int unkindex3;

	// BVH4 size (?)
	Vector3 mins;
	Vector3 maxs; // seem to be the same as hull size

	int bvh4index; // bvh4 tree

	short unk4_v54[2]; // same as unk3_v54_v121, 2nd might be base for other offsets?

	int vvwindex;
	int vvwsize;

	inline s3studiohdr_t Downgrade()
	{
		s3studiohdr_t out{};
		out.flags = this->flags;
		out.surfacepropindex = this->surfacepropindex;
		out.contents = this->contents;
		out.eyeposition = this->eyeposition;
		out.illumposition = this->illumposition;
		out.numbones = this->numbones;
		out.boneindex = this->boneindex;
		out.numbodyparts = this->numbodyparts;
		out.bodypartindex = this->bodypartindex;
		out.numlocalattachments = this->numlocalattachments;
		out.localattachmentindex = this->localattachmentindex;
		out.numskinfamilies = this->numskinfamilies;
		out.skinindex = this->skinindex;
		out.numskinref = this->numskinref;
		out.numhitboxsets = this->numhitboxsets;
		out.hitboxsetindex = this->hitboxsetindex;
		out.textureindex = this->textureindex;
		out.numtextures = this->numtextures;
		out.ikchainindex = this->ikchainindex;
		out.ikchainindex = this->numikchains;
		out.localposeparamindex = this->localposeparamindex;
		out.numlocalposeparameters = this->numlocalposeparameters;
		out.keyvalueindex = this->keyvalueindex;
		return out;
	}
};

struct studiohdr_t_v13
{
	int id; // Model format ID, such as "IDST" (0x49 0x44 0x53 0x54)
	int version; // Format version number, such as 48 (0x30,0x00,0x00,0x00)
	int checksum; // This has to be the same in the phy and vtx files to load!
	int sznameindex; // This has been moved from studiohdr2 to the front of the main header.
	char name[64]; // The internal name of the model, padding with null bytes.
	// Typically "my_model.mdl" will have an internal name of "my_model"
	int length; // Data size of MDL file in bytes.

	Vector3 eyeposition;	// ideal eye position

	Vector3 illumposition;	// illumination center

	Vector3 hull_min;		// ideal movement hull size
	Vector3 hull_max;

	Vector3 view_bbmin;		// clipping bounding box
	Vector3 view_bbmax;

	int flags;

	int numbones; // bones
	int boneindex;

	int numbonecontrollers; // bone controllers
	int bonecontrollerindex;

	int numhitboxsets;
	int hitboxsetindex;

	// unused now
	int numlocalanim; // animations/poses
	int localanimindex; // animation descriptions

	int numlocalseq; // sequences
	int	localseqindex;

	int activitylistversion; // initialization flag - have the sequences been indexed?

	// mstudiotexture_t
	// short rpak path
	// raw textures
	int materialtypesindex;
	int numtextures; // the material limit exceeds 128, probably 256.
	int textureindex;

	// this should always only be one, unless using vmts.
	// raw textures search paths
	int numcdtextures;
	int cdtextureindex;

	// replaceable textures tables
	int numskinref;
	int numskinfamilies;
	int skinindex;

	int numbodyparts;
	int bodypartindex;

	int numlocalattachments;
	int localattachmentindex;

	int numlocalnodes;
	int localnodeindex;
	int localnodenameindex;

	int numunknodes;
	int unknodexindex;

	int numikchains;
	int ikchainindex;

	// this is rui meshes
	int numruimeshes;
	int ruimeshindex;

	int numlocalposeparameters;
	int localposeparamindex;

	int surfacepropindex;

	int keyvalueindex;
	int keyvaluesize;

	int numlocalikautoplaylocks;
	int localikautoplaylockindex;

	float mass;
	int contents;

	// unused for packed models
	int numincludemodels;
	int includemodelindex;

	uint32_t virtualModel;

	int bonetablebynameindex;

	// stuff moved from vg in v12.1
	int numVGMeshes; // total number of meshes, not including LODs
	int vgMeshIndex;

	int boneStateIndex;
	int numBoneStates;

	int unk_v54_v121; // related to vg likely

	int vgSize;

	short vgUnk; // same as padding in vg header
	int16_t vgLODCount; // same as lod count in vg header

	int vgNumUnknown; // same as unk1 in vg header

	int vgHeaderIndex;
	int numVGHeaders;

	int vgLODIndex;
	int numVGLODs;

	float fadeDistance;

	float gathersize; // what. from r5r struct

	float flVertAnimFixedPointScale; // to be verified
	int surfacepropLookup; // saved in the file

	int unk_v54_v122; // added in transition version

	// asset bakery strings if it has any
	int sourceFilenameOffset;

	int numsrcbonetransform;
	int srcbonetransformindex;

	int	illumpositionattachmentindex;

	int linearboneindex;

	// unsure what this is for but it exists for jigglbones
	int numprocbonesunk;
	int procbonearrayindex;
	int procbonemaskindex;

	// always "" or "Titan"
	int unkstringindex;

	// the indexes are added to the offset in the rpak mdl_ header.
	// vphy isn't vphy, looks like a heavily modified vphy.
	// something different about these now
	int vtxindex; // VTX
	int vvdindex; // VVD / IDSV
	int vvcindex; // VVC / IDCV 
	int vphyindex; // VPHY / IVPS

	int vtxsize;
	int vvdsize;
	int vvcsize;
	int vphysize;

	// only seen on '_animated' suffixed models so far
	int unkcount3;
	int unkindex3;

	// BVH4 size (?)
	Vector3 mins;
	Vector3 maxs; // seem to be the same as hull size

	int bvh4index; // bvh4 tree

	short unk4_v54[2]; // same as unk3_v54_v121, 2nd might be base for other offsets?

	int vvwindex;
	int vvwsize;

	int unk1_v54_v13[3];

	inline s3studiohdr_t Downgrade()
	{
		s3studiohdr_t out{};
		out.flags = this->flags;
		out.surfacepropindex = this->surfacepropindex;
		out.contents = this->contents;
		out.eyeposition = this->eyeposition;
		out.illumposition = this->illumposition;
		out.numbones = this->numbones;
		out.boneindex = this->boneindex;
		out.numbodyparts = this->numbodyparts;
		out.bodypartindex = this->bodypartindex;
		out.numlocalattachments = this->numlocalattachments;
		out.localattachmentindex = this->localattachmentindex;
		out.numskinfamilies = this->numskinfamilies;
		out.skinindex = this->skinindex;
		out.numskinref = this->numskinref;
		out.numhitboxsets = this->numhitboxsets;
		out.hitboxsetindex = this->hitboxsetindex;
		out.textureindex = this->textureindex;
		out.numtextures = this->numtextures;
		out.ikchainindex = this->ikchainindex;
		out.ikchainindex = this->numikchains;
		out.localposeparamindex = this->localposeparamindex;
		out.numlocalposeparameters = this->numlocalposeparameters;
		out.keyvalueindex = this->keyvalueindex;
		return out;
	}
};

struct studiohdr_t_v14
{
	int id; // Model format ID, such as "IDST" (0x49 0x44 0x53 0x54)
	int version; // Format version number, such as 48 (0x30,0x00,0x00,0x00)
	int checksum; // This has to be the same in the phy and vtx files to load!
	int sznameindex; // No longer stored in string block, uses string in header.
	char name[64]; // The internal name of the model, padding with null bytes.
	// Typically "my_model.mdl" will have an internal name of "my_model"
	int length; // Data size of MDL file in bytes.

	Vector3 eyeposition;	// ideal eye position

	Vector3 illumposition;	// illumination center

	Vector3 hull_min;		// ideal movement hull size
	Vector3 hull_max;

	Vector3 view_bbmin;		// clipping bounding box
	Vector3 view_bbmax;

	int flags;

	int numbones; // bones
	int boneindex;

	int numbonecontrollers; // bone controllers
	int bonecontrollerindex;

	int numhitboxsets;
	int hitboxsetindex;

	// unused now
	int numlocalanim; // animations/poses
	int localanimindex; // animation descriptions

	int numlocalseq; // sequences
	int	localseqindex;

	int unk_v54_v14[2]; // added in v13 -> v14

	int activitylistversion; // initialization flag - have the sequences been indexed?

	// mstudiotexture_t
	// short rpak path
	// raw textures
	int materialtypesindex;
	int numtextures; // the material limit exceeds 128, probably 256.
	int textureindex;

	// this should always only be one, unless using vmts.
	// raw textures search paths
	int numcdtextures;
	int cdtextureindex;

	// replaceable textures tables
	int numskinref;
	int numskinfamilies;
	int skinindex;

	int numbodyparts;
	int bodypartindex;

	int numlocalattachments;
	int localattachmentindex;

	int numlocalnodes;
	int localnodeindex;
	int localnodenameindex;

	int numunknodes;
	int unknodexindex;

	int numikchains;
	int ikchainindex;

	// this is rui meshes
	int numruimeshes;
	int ruimeshindex;

	int numlocalposeparameters;
	int localposeparamindex;

	int surfacepropindex;

	int keyvalueindex;
	int keyvaluesize;

	int numlocalikautoplaylocks;
	int localikautoplaylockindex;

	float mass;
	int contents;

	// unused for packed models
	int numincludemodels;
	int includemodelindex;

	uint32_t virtualModel;

	int bonetablebynameindex;

	// stuff moved from vg in v12.1
	int numVGMeshes; // total number of meshes, not including LODs
	int vgMeshIndex;

	int boneStateIndex;
	int numBoneStates;

	int unk_v54_v121; // related to vg likely

	int vgSize;

	short vgUnk; // same as padding in vg header
	int16_t vgLODCount; // same as lod count in vg header

	int vgNumUnknown; // same as unk1 in vg header

	int vgHeaderIndex;
	int numVGHeaders;

	int vgLODIndex;
	int numVGLODs;

	float fadeDistance;

	float gathersize; // what. from r5r struct

	float flVertAnimFixedPointScale; // to be verified
	int surfacepropLookup; // saved in the file

	int unk_v54_v122; // added in transition version

	// asset bakery strings if it has any
	int sourceFilenameOffset;

	int numsrcbonetransform;
	int srcbonetransformindex;

	int	illumpositionattachmentindex;

	int linearboneindex;

	// unsure what this is for but it exists for jigglbones
	int numprocbonesunk;
	int procbonearrayindex;
	int procbonemaskindex;

	// always "" or "Titan"
	int unkstringindex;

	// the indexes are added to the offset in the rpak mdl_ header.
	// vphy isn't vphy, looks like a heavily modified vphy.
	// something different about these now
	int vtxindex; // VTX
	int vvdindex; // VVD / IDSV
	int vvcindex; // VVC / IDCV 
	int vphyindex; // VPHY / IVPS

	int vtxsize;
	int vvdsize;
	int vvcsize;
	int vphysize;

	// only seen on '_animated' suffixed models so far
	int unkcount3;
	int unkindex3;

	// BVH4 size (?)
	Vector3 mins;
	Vector3 maxs; // seem to be the same as hull size

	int bvh4index; // bvh4 tree

	short unk4_v54[2]; // same as unk3_v54_v121, 2nd might be base for other offsets?

	int vvwindex;
	int vvwsize;

	int unk1_v54_v13[3];

	inline s3studiohdr_t Downgrade()
	{
		s3studiohdr_t out{};
		out.flags = this->flags;
		out.surfacepropindex = this->surfacepropindex;
		out.contents = this->contents;
		out.eyeposition = this->eyeposition;
		out.illumposition = this->illumposition;
		out.numbones = this->numbones;
		out.boneindex = this->boneindex;
		out.numbodyparts = this->numbodyparts;
		out.bodypartindex = this->bodypartindex;
		out.numlocalattachments = this->numlocalattachments;
		out.localattachmentindex = this->localattachmentindex;
		out.numskinfamilies = this->numskinfamilies;
		out.skinindex = this->skinindex;
		out.numskinref = this->numskinref;
		out.numhitboxsets = this->numhitboxsets;
		out.hitboxsetindex = this->hitboxsetindex;
		out.textureindex = this->textureindex;
		out.numtextures = this->numtextures;
		out.ikchainindex = this->ikchainindex;
		out.ikchainindex = this->numikchains;
		out.localposeparamindex = this->localposeparamindex;
		out.numlocalposeparameters = this->numlocalposeparameters;
		out.keyvalueindex = this->keyvalueindex;
		return out;
	}
};

struct studiohdr_t_v16
{
	int flags;
	int checksum; // unsure if this is still checksum, there isn't any other files that have it still
	short sznameindex; // No longer stored in string block, uses string in header.
	char name[32]; // The internal name of the model, padding with null bytes.
	// Typically "my_model.mdl" will have an internal name of "my_model"
	byte unk_v16;

	byte surfacepropLookup; // saved in the file

	float mass;

	int unk1_v16;

	uint16 hitboxsetindex;
	byte numhitboxsets;

	byte illumpositionattachmentindex;

	Vector3 illumposition;	// illumination center

	Vector3 hull_min;		// ideal movement hull size
	Vector3 hull_max;

	Vector3 view_bbmin;		// clipping bounding box
	Vector3 view_bbmax;

	short numbones; // bones
	uint16 boneindex;
	uint16 bonedataindex;

	short numlocalseq; // sequences
	uint16 localseqindex;

	byte unkfill[5];

	byte numlocalattachments;
	uint16 localattachmentindex;

	short numlocalnodes;
	uint16 localnodenameindex;
	uint16 localnodeindex;

	short numikchains;
	uint16 ikchainindex;

	short numtextures; // the material limit exceeds 128, probably 256.
	uint16 textureindex;

	// replaceable textures tables
	short numskinref;
	short numskinfamilies;
	uint16 skinindex;

	short numbodyparts;
	uint16 bodypartindex;

	// this is rui meshes
	short numruimeshes;
	uint16 ruimeshindex;

	short numlocalposeparameters;
	uint16 localposeparamindex;

	uint16 surfacepropindex;

	uint16 keyvalueindex;

	uint16 vgmeshindex;
	short numvgmeshes;

	short bonetablebynameindex;

	uint16 boneremapindex;
	short numboneremaps;

	uint16 vgloddataindex;
	short numvgloddata;

	uint16 vglodheaderindex;
	short numvglodheader;

	float fadedistance;

	float gathersize; // what. from r5r struct

	short numsrcbonetransform;
	uint16 srcbonetransformindex;

	// asset bakery strings if it has any
	uint16 mayaindex;

	uint16 linearboneindex;

	short m_nBoneFlexDriverCount; // unsure if that's what it is in apex
	uint16 m_nBoneFlexDriverIndex;
	uint16 unkindexflex;

	short unkcount3; // same as v54
	uint16 unkindex3; // same as v54

	uint16 unkindex4; // same as v54

	byte unk5_v16; // unk4_v54[0]
	byte unk6_v16; // unk4_v54[1]
	short unk7_v16; // unk4_v54[2]
	short unk8_v16;
	short unk9_v16;

	//uint16 unkshorts[7];

	inline s3studiohdr_t Downgrade()
	{
		s3studiohdr_t out{};
		out.flags = this->flags;
		out.surfacepropindex = (int)this->surfacepropindex;
		out.illumposition = this->illumposition;
		out.numbones = (int)this->numbones;
		out.boneindex = (int)this->boneindex;
		out.numbodyparts = (int)this->numbodyparts;
		out.bodypartindex = (int)this->bodypartindex;
		out.numlocalattachments = (int)this->numlocalattachments;
		out.localattachmentindex = (int)this->localattachmentindex;
		out.numskinfamilies = (int)this->numskinfamilies;
		out.skinindex = (int)this->skinindex;
		out.numskinref = (int)this->numskinref;
		out.numhitboxsets = (int)this->numhitboxsets;
		out.hitboxsetindex = (int)this->hitboxsetindex;
		out.textureindex = (int)this->textureindex;
		out.numtextures = (int)this->numtextures;
		out.ikchainindex = (int)this->ikchainindex;
		out.ikchainindex = (int)this->numikchains;
		out.localposeparamindex = (int)this->localposeparamindex;
		out.numlocalposeparameters = (int)this->numlocalposeparameters;
		out.keyvalueindex = (int)this->keyvalueindex;
		return out;
	}
};

struct studiohdr_t // latest studiohdr
{
	int id; // Model format ID, such as "IDST" (0x49 0x44 0x53 0x54)
	int version; // Format version number, such as 48 (0x30,0x00,0x00,0x00)
	int checksum; // This has to be the same in the phy and vtx files to load!
	int sznameindex; // This has been moved from studiohdr2 to the front of the main header.
	char name[64]; // The internal name of the model, padding with null bytes.
	// Typically "my_model.mdl" will have an internal name of "my_model"
	int length; // Data size of MDL file in bytes.

	Vector3 eyeposition;	// ideal eye position

	Vector3 illumposition;	// illumination center

	Vector3 hull_min;		// ideal movement hull size
	Vector3 hull_max;

	Vector3 view_bbmin;		// clipping bounding box
	Vector3 view_bbmax;

	int flags;

	int numbones; // bones
	int boneindex;

	int numbonecontrollers; // bone controllers
	int bonecontrollerindex;

	int numhitboxsets;
	int hitboxsetindex;

	int numlocalanim; // animations/poses
	int localanimindex; // animation descriptions

	int numlocalseq; // sequences
	int	localseqindex;

	int activitylistversion; // initialization flag - have the sequences been indexed?

	// mstudiotexture_t
	// short rpak path
	// raw textures
	int materialtypesindex;
	int numtextures; // the material limit exceeds 128, probably 256.
	int textureindex;

	// this should always only be one, unless using vmts.
	// raw textures search paths
	int numcdtextures;
	int cdtextureindex;

	// replaceable textures tables
	int numskinref;
	int numskinfamilies;
	int skinindex;

	int numbodyparts;
	int bodypartindex;

	int numlocalattachments;
	int localattachmentindex;

	uint8_t Unknown2[0x18];

	uint32_t SubmeshLodsOffset;

	uint32_t OffsetToBoneRemapInfo;
	uint32_t BoneRemapCount;

	inline void FromS3(s3studiohdr_t n)
	{

		for (int i = 0; i < 64; i++)
			this->name[i] = n.name[i];

		this->id = n.id;
		this->version = n.version;
		this->checksum = n.checksum;
		this->sznameindex = n.sznameindex;
		this->length = n.length;
		this->eyeposition = n.eyeposition;
		this->illumposition = n.illumposition;
		this->hull_min = n.hull_min;
		this->hull_max = n.hull_max;
		this->view_bbmin = n.view_bbmin;
		this->view_bbmax = n.view_bbmax;
		this->flags = n.flags;
		this->numbones = n.numbones;
		this->boneindex = n.boneindex;
		this->numbonecontrollers = n.numbonecontrollers;
		this->bonecontrollerindex = n.bonecontrollerindex;
		this->numhitboxsets = n.numhitboxsets;
		this->hitboxsetindex = n.hitboxsetindex;
		this->numlocalanim = n.numlocalanim;
		this->localanimindex = n.localanimindex;
		this->numlocalseq = n.numlocalseq;
		this->localseqindex = n.localseqindex;
		this->activitylistversion = n.activitylistversion;
		this->materialtypesindex = n.materialtypesindex;
		this->numtextures = n.numtextures;
		this->textureindex = n.textureindex;
		this->numcdtextures = n.numcdtextures;
		this->cdtextureindex = n.cdtextureindex;
		this->numskinref = n.numskinref;
		this->numskinfamilies = n.numskinfamilies;
		this->skinindex = n.skinindex;
		this->numbodyparts = n.numbodyparts;
		this->bodypartindex = n.bodypartindex;
		this->numlocalattachments = n.numlocalattachments;
		this->localattachmentindex = n.localattachmentindex;
		this->SubmeshLodsOffset = n.meshindex; // what?
		this->OffsetToBoneRemapInfo = 0;
		this->BoneRemapCount = 0;
	}

	inline void FromV13(studiohdr_t_v13 n)
	{
		for (int i = 0; i < 64; i++)
			this->name[i] = n.name[i];

		this->id = n.id;
		this->version = n.version;
		this->checksum = n.checksum;
		this->sznameindex = n.sznameindex;
		this->length = n.length;
		this->eyeposition = n.eyeposition;
		this->illumposition = n.illumposition;
		this->hull_min = n.hull_min;
		this->hull_max = n.hull_max;
		this->view_bbmin = n.view_bbmin;
		this->view_bbmax = n.view_bbmax;
		this->flags = n.flags;
		this->numbones = n.numbones;
		this->boneindex = n.boneindex;
		this->numbonecontrollers = n.numbonecontrollers;
		this->bonecontrollerindex = n.bonecontrollerindex;
		this->numhitboxsets = n.numhitboxsets;
		this->hitboxsetindex = n.hitboxsetindex;
		this->numlocalanim = n.numlocalanim;
		this->localanimindex = n.localanimindex;
		this->numlocalseq = n.numlocalseq;
		this->localseqindex = n.localseqindex;
		this->activitylistversion = n.activitylistversion;
		this->materialtypesindex = n.materialtypesindex;
		this->numtextures = n.numtextures;
		this->textureindex = n.textureindex;
		this->numcdtextures = n.numcdtextures;
		this->cdtextureindex = n.cdtextureindex;
		this->numskinref = n.numskinref;
		this->numskinfamilies = n.numskinfamilies;
		this->skinindex = n.skinindex;
		this->numbodyparts = n.numbodyparts;
		this->bodypartindex = n.bodypartindex;
		this->numlocalattachments = n.numlocalattachments;
		this->localattachmentindex = n.localattachmentindex;
		this->SubmeshLodsOffset = n.ikchainindex; // what?
		this->OffsetToBoneRemapInfo = n.boneStateIndex;
		this->BoneRemapCount = n.numBoneStates;
	}

	inline void FromV14(studiohdr_t_v14 n)
	{
		for (int i = 0; i < 64; i++)
			this->name[i] = n.name[i];

		this->id = n.id;
		this->version = n.version;
		this->checksum = n.checksum;
		this->sznameindex = n.sznameindex;
		this->length = n.length;
		this->eyeposition = n.eyeposition;
		this->illumposition = n.illumposition;
		this->hull_min = n.hull_min;
		this->hull_max = n.hull_max;
		this->view_bbmin = n.view_bbmin;
		this->view_bbmax = n.view_bbmax;
		this->flags = n.flags;
		this->numbones = n.numbones;
		this->boneindex = n.boneindex;
		this->numbonecontrollers = n.numbonecontrollers;
		this->bonecontrollerindex = n.bonecontrollerindex;
		this->numhitboxsets = n.numhitboxsets;
		this->hitboxsetindex = n.hitboxsetindex;
		this->numlocalanim = n.numlocalanim;
		this->localanimindex = n.localanimindex;
		this->numlocalseq = n.numlocalseq;
		this->localseqindex = n.localseqindex;
		this->activitylistversion = n.activitylistversion;
		this->materialtypesindex = n.materialtypesindex;
		this->numtextures = n.numtextures;
		this->textureindex = n.textureindex;
		this->numcdtextures = n.numcdtextures;
		this->cdtextureindex = n.cdtextureindex;
		this->numskinref = n.numskinref;
		this->numskinfamilies = n.numskinfamilies;
		this->skinindex = n.skinindex;
		this->numbodyparts = n.numbodyparts;
		this->bodypartindex = n.bodypartindex;
		this->numlocalattachments = n.numlocalattachments;
		this->localattachmentindex = n.localattachmentindex;
		this->SubmeshLodsOffset = n.ikchainindex; // what?
		this->OffsetToBoneRemapInfo = n.boneStateIndex;
		this->BoneRemapCount = n.numBoneStates;
	}
};

struct mstudioikchainv54_t
{
	int sznameindex;

	int linktype;
	int numlinks;
	int linkindex;

	float unk; // no clue what this does tbh, tweaking it does nothing
	// default value: 0.707f
};

struct mstudioikchainv54_t_v16
{
	uint16_t sznameindex;

	short linktype;
	short numlinks;
	uint16_t linkindex;

	float unk; // no clue what this does tbh, tweaking it does nothing
	// default value: 0.707f
};

// ikinfo
struct mstudioiklinkv54_t
{
	int bone;
	Vector3	unused0; // no kneeDir in apex I think
};

struct mstudiolinearbone_t_v16
{
	unsigned short numbones;

	unsigned short flagsindex; // int

	unsigned short parentindex; // short

	unsigned short posindex; // vector3

	unsigned short quatindex; // quaternion

	unsigned short rotindex; // radianeuler

	unsigned short posetoboneindex; // matrix3x4_t
};

struct vgloddata_t_v16
{
	int vgoffset; // offset to this section in vg
	int vgsizecompressed;
	int vgsizedecompressed; // decompressed size of data in vg

	byte numMeshes;

	// this could also be vg section index
	byte lodlevel; // 0, 1, 2, 3, etc
	byte numlods; // normally 1, stolen from vg structs

	// ids for something
	byte unk2; // powers of two
};

struct mstudiobone_t
{
	uint32_t NameOffset;		// Relative to current position
	int32_t ParentIndex;

	int BoneControllers[6]; // -1 if none

	Math::Vector3 Position;		// Local
	Math::Quaternion Rotation;	// Local

	uint8_t Padding[0x78];
};

struct r2mstudiobone_t
{
	uint32_t NameOffset;		// Relative to current position
	int32_t ParentIndex;

	int BoneControllers[6]; // -1 if none

	Math::Vector3 Position;		// Local
	Math::Quaternion Rotation;	// Local
	Math::Vector3 EulerRotation;

	Math::Vector3 PositionScale;
	Math::Vector3 RotationScale;

	uint8_t Padding[0x88];
};

struct mstudiobone_t_v16
{
	int contents;

	byte unk;

	byte surfacepropLookup; // written on compile in v54+
	short surfacepropidx; // index into string tablefor property name
	short physicsbone; // index into physically simulated bone
	short sznameindex;
};

struct mstudiobonedata_t_v16
{
	matrix3x4_t poseToBone;
	Math::Quaternion qAlignment;

	// default values
	Math::Vector3 pos;
	Math::Quaternion quat;
	Math::Vector3 rot;
	Vector3 scale; // bone scale(?)

	short parent; // parent bone;

	short unk1;

	int flags;

	byte unkid;

	byte proctype;
	uint16 procindex; // procedural rule

};

struct mstudiomodelv54_t
{
	char name[64];

	int unkindex2; // byte before string block

	// these are probably still used but get written over the name if nothing is set.
	//int type;
	//float boundingradius;

	char name2[8]; // it looks like they write the entire name
	// then write over it with other values where needed
	// why.

	int nummeshes;
	int meshindex;

	// cache purposes
	int numvertices; // number of unique vertices/normals/texcoords
	int vertexindex; // vertex Vector
	int tangentsindex; // tangents Vector

	int numattachments;
	int attachmentindex;

	// might be cut
	int numeyeballs;
	int eyeballindex;

	//mstudio_modelvertexdata_t vertexdata;

	// same as v53, except trimming the fat
	int unk[4];

	int unkindex;
	int unkindex1;
};

struct mstudiomodelv54_t_v13
{
	char name[64];

	int unkindex2; // byte before string block

	// it looks like they write the entire name
	// then write over it with other values where needed
	// why.
	int type;

	float boundingradius;

	int nummeshes;
	int meshindex;

	// cache purposes
	int numvertices; // number of unique vertices/normals/texcoords
	int vertexindex; // vertex Vector
	int tangentsindex; // tangents Vector

	int numattachments;
	int attachmentindex;

	int colorindex; // vertex color
	// offset by colorindex number of bytes into vvc vertex colors
	int uv2index; // vertex second uv map
	// offset by uv2index number of bytes into vvc secondary uv map

	int unk; // same as uv2index, did they add something to vvc/0tVG?

	inline mstudiomodelv54_t Downgrade()
	{
		mstudiomodelv54_t out{};

		for (int i = 0; i < 64; i++)
			out.name[i] = this->name[i];

		out.unkindex2 = this->unkindex2;
		out.nummeshes = this->nummeshes;
		out.meshindex = this->meshindex;
		out.numvertices = this->numvertices;
		out.vertexindex = this->vertexindex;
		out.tangentsindex = this->tangentsindex;
		out.numattachments = this->numattachments;
		out.attachmentindex = this->attachmentindex;

		return out;
	}
};

struct mstudiomodelv54_t_v14
{
	char name[64];

	int unkindex2; // byte before string block

	// they write over these two when it's the default
	int type;

	float boundingradius;

	int nummeshes;

	// first is the same as nummeshes?
	int unk_v14;
	int unk1_v14;

	int meshindex;

	// most of these vtx, vvd, vvc, and vg indexes are depreciated after v14.1 (s14)

	// cache purposes
	int numvertices; // number of unique vertices/normals/texcoords
	int vertexindex; // vertex Vector
	int tangentsindex; // tangents Vector

	int numattachments;
	int attachmentindex;

	int colorindex; // vertex color
	int uv2index; // vertex second uv map
	int unk;

	inline mstudiomodelv54_t Downgrade()
	{
		mstudiomodelv54_t out{};

		for (int i = 0; i < 64; i++)
			out.name[i] = this->name[i];

		out.unkindex2 = this->unkindex2;
		out.nummeshes = this->nummeshes;
		out.meshindex = this->meshindex;
		out.numvertices = this->numvertices;
		out.vertexindex = this->vertexindex;
		out.tangentsindex = this->tangentsindex;
		out.numattachments = this->numattachments;
		out.attachmentindex = this->attachmentindex;

		return out;
	}
};

struct mstudiomodelv54_t_v16
{
	short unkindex2;
	short nummeshes;

	// first is the same as nummeshes?
	short unk_v14;
	short unk1_v14;

	short meshindex;

	inline mstudiomodelv54_t Downgrade()
	{
		mstudiomodelv54_t out{};

		out.unkindex2 = this->unkindex2;
		out.nummeshes = this->nummeshes;
		out.meshindex = this->meshindex;

		return out;
	}
};

#define MAX_NUM_LODS 8

struct mstudio_meshvertexloddata_t
{
	int modelvertexdataUnusedPad; // likely has none of the funny stuff because unused

	int numLODVertexes[MAX_NUM_LODS]; // depreciated starting with rmdl v14(?)
};


struct mstudiomeshv54_t
{
	int material;

	int modelindex;

	int numvertices; // number of unique vertices/normals/texcoords
	int vertexoffset; // vertex mstudiovertex_t

	// Access thin/fat mesh vertex data (only one will return a non-NULL result)

	int deprecated_numflexes; // vertex animation
	int deprecated_flexindex;

	// special codes for material operations
	int deprecated_materialtype;
	int deprecated_materialparam;

	// a unique ordinal for this mesh
	int meshid;

	Vector3 center;

	mstudio_meshvertexloddata_t vertexloddata;

	int unk[2]; // these are suposed to be filled on load, however this isn't true??
};

struct mstudiomeshv54_t_v121
{
	int material;

	int modelindex;

	int numvertices; // number of unique vertices/normals/texcoords
	int vertexoffset; // vertex mstudiovertex_t

	// a unique ordinal for this mesh
	int meshid;

	Vector3 center;

	// depreciated in later versions?
	mstudio_meshvertexloddata_t vertexloddata;

	int unk[2]; // these are suposed to be filled on load, however this isn't true??

	inline mstudiomeshv54_t Downgrade()
	{
		mstudiomeshv54_t out{};
		out.material = this->material;
		out.modelindex = this->modelindex;
		out.numvertices = this->numvertices;
		out.vertexoffset = this->vertexoffset;
		out.meshid = this->meshid;
		out.center = this->center;
		out.vertexloddata = this->vertexloddata;
		out.unk[0] = this->unk[0];
		out.unk[1] = this->unk[1];

		return out;
	}
};

struct mstudiomeshv54_t_v16
{
	short material;
	// a unique ordinal for this mesh
	short meshid;
	byte unk[4];
	Vector3 center;

	inline mstudiomeshv54_t Downgrade()
	{
		mstudiomeshv54_t out{};
		out.material = this->material;
		out.meshid = this->meshid;
		out.center = this->center;
		return out;
	}
};

struct RMdlMeshStreamHeader
{
	uint32_t Version;
	uint32_t VertCacheSize;

	uint16_t MaxBonesPerStrip;
	uint16_t MaxBonesPerTri;

	uint32_t MaxBonesPerVert;
	uint32_t Hash;

	uint32_t NumLods;

	uint32_t MaterialReplacementOffset;		// Add 0x8 * 0x4 to get end of file.

	uint32_t NumBodyParts;
	uint32_t BodyPartOffset;
};

struct vertexFileHeader_t
{
	int id;
	int version;
	uint32_t checksum;

	int numLODs;
	int numLODVertexes[8];

	int numFixups;
	int fixupTableStart;

	int vertexDataStart;
	int tangentDataStart;
};

struct RMdlVGHeaderOld
{
	uint32_t Magic;		// 0x47567430	'0tvg'
	uint32_t Version;	// 0x1
	uint32_t Unknown;	// Usually 0
	uint32_t DataSize;	// Total size of data + header in starpak

	uint64_t BoneRemapOffset;
	uint64_t BoneRemapCount;		// Only 1 byte each

	uint64_t MeshOffset;
	uint64_t MeshCount;		// 0x48 each

	uint64_t IndexOffset;
	uint64_t IndexCount;		// 0x2 each (uint16_t)

	uint64_t VertexBufferOffset;
	uint64_t VertexBufferSize; // 1 byte each

	uint64_t ExtendedWeightsOffset;
	uint64_t ExtendedWeightsCount;		// Only 1 byte per count

	uint64_t Unknown2Offset;
	uint64_t Unknown2Count;		// 0x30 each

	uint64_t LodOffset;
	uint64_t LodCount;			// 0x8 each

	uint64_t ExternalWeightsOffset;
	uint64_t ExternalWeightsCount;	// 0x10 each

	uint64_t StripsOffset;
	uint64_t StripsCount;			// 0x23 each
};

struct RMdlVGHeader
{
	int id;		// 0x47567430	'0tVG'
	int version;	// 0x1
	int padding;
	uint32_t lodCount;	// If 0x1, this IS the first and only lod, if > 0x1, MORE 0tVG headers follow PER lod count
	uint32_t unk;
	uint32_t unk1;
	uint32_t lodOffset;
	char unk3[8];
};

struct VGHeader_t_v16
{
	short unk0;
	short unk2;
	int unk4;
	int nummeshes;
	int meshindex;
};

struct VGLod
{
	char unk[4];
	uint32_t dataSize;
	short meshCount;
	char unk1; // both of these bytes line up with the LOD index
	char unk2;
	float distance;
	uint64_t meshOffset;
};

struct RMdlVGIndexCountPacked
{
	uint64_t Count : 56;
	uint64_t Type : 8;
};

struct RMdlVGIndexCountPacked_V16
{
	unsigned int Count : 24;
	unsigned int Type : 8;
};

struct VGMesh_t_v16
{
	uint64_t flags;
	int vertexCount;
	short vertexSize;
	short unk;
	int indexOffset;
	RMdlVGIndexCountPacked_V16 indexPacked;
	int vertexOffset;
	int vertexBufferSize;

	int weightsOffset;
	int weightsCount;

	int unkOffset;
	int unkCount;
};

struct RMdlVGMesh
{
	uint32_t Flags1;					// Flags that pertain to this mesh
	uint32_t Flags2;					// Also flags that pertain to this mesh
	uint32_t VertexBufferStride;		// Stride in bytes of the vertex buffer
	uint32_t VertexCount;				// Count of vertices used

	uint64_t IndexOffset;
	RMdlVGIndexCountPacked IndexPacked;	// 0x2 each (uint16_t)

	uint64_t VertexOffset;
	uint64_t VertexCountBytes;		// 0x1 each aka, in bytes

	uint64_t ExtendedWeightsOffset;
	uint64_t ExtendedWeightsCount;		// Only 1 byte per count

	uint64_t ExternalWeightsOffset;
	uint64_t ExternalWeightsCount;	// 0x10 each

	uint64_t StripsOffset;
	uint64_t StripsCount;			// 0x23 each
};

struct RMdlVGMesh_V14
{
	uint32_t Flags1;					// Flags that pertain to this mesh
	uint32_t Flags2;					// Also flags that pertain to this mesh
	uint32_t VertexBufferStride;		// Stride in bytes of the vertex buffer
	uint32_t VertexCount;				// Count of vertices used

	uint64_t IndexOffset;
	RMdlVGIndexCountPacked IndexPacked;	// 0x2 each (uint16_t)

	uint64_t VertexOffset;
	uint64_t VertexCountBytes;		// 0x1 each aka, in bytes

	uint64_t ExtendedWeightsOffset;
	uint64_t ExtendedWeightsCount; // idk if these are actually unused but it looks like they are

	uint64_t ExternalWeightsOffset;
	uint64_t ExternalWeightsCount;	// 0x10 each

	uint64_t StripsOffset;
	uint64_t StripsCount;			// 0x23 each

	uint64_t UnkOffset;
	uint64_t UnkCount;		// Only 1 byte per count
};

struct RMdlVGMeshOld
{
	uint32_t Flags1;					// Flags that pertain to this mesh
	uint32_t Flags2;					// Also flags that pertain to this mesh
	uint32_t VertexOffsetBytes;			// Offset into vertex buffer by bytes
	uint32_t VertexBufferStride;		// Stride in bytes of the vertex buffer
	uint32_t VertexCount;				// Count of vertices used
	uint32_t Int6;
	uint32_t ExtendedWeightsOffset;		// Offset into the extended weights buffer
	uint32_t ExtendedWeightsSize;		// Size or count of extended weights used by this mesh
	uint32_t IndexOffset;				// Some form of index offset
	uint32_t IndexCount;				// Some form of index count
	uint32_t VertexOffset2;				// Some form of vertex offset (Not always used??)
	uint32_t VertexCount2;				// some form of vertex count
	uint32_t StripsIndex;				// Index into the strips structs
	uint32_t StripsCount;
	uint32_t Int15;
	uint32_t Int16;
	uint32_t Int17;
	uint32_t Int18;
};

struct RMdlVGStrip
{
	uint32_t IndexCount;
	uint32_t IndexOffset;

	uint32_t VertexCount;
	uint32_t VertexOffset;

	uint16_t NumBones;

	uint8_t StripFlags;

	uint8_t Padding[0x10];
};

struct RMdlVGLod
{
	uint16_t MeshIndex;
	uint16_t MeshCount;
	float Distance;
};

struct RMdlPhyHeader
{
	uint32_t HeaderSize;
	uint32_t Id;
	uint32_t SolidCount;
	uint32_t Checksum;
	uint32_t TextOffset; // offset to the text section
};

#define LAST_IND(x,part_type)    (sizeof(x)/sizeof(part_type) - 1)
#if defined(__BYTE_ORDER) && __BYTE_ORDER == __BIG_ENDIAN
#  define LOW_IND(x,part_type)   LAST_IND(x,part_type)
#  define HIGH_IND(x,part_type)  0
#else
#  define HIGH_IND(x,part_type)  LAST_IND(x,part_type)
#  define LOW_IND(x,part_type)   0
#endif

#define BYTEn(x, n)   (*((uint8_t*)&(x)+n))
#define WORDn(x, n)   (*((uint16_t*)&(x)+n))
#define DWORDn(x, n)  (*((uint32_t*)&(x)+n))
#define LOBYTE(x)  BYTEn(x,LOW_IND(x,uint8_t))
#define LOWORD(x)  WORDn(x,LOW_IND(x,uint16_t))
#define LODWORD(x) DWORDn(x,LOW_IND(x,uint32_t))
#define HIBYTE(x)  BYTEn(x,HIGH_IND(x,uint8_t))
#define HIWORD(x)  WORDn(x,HIGH_IND(x,uint16_t))
#define HIDWORD(x) DWORDn(x,HIGH_IND(x,uint32_t))
#define BYTE1(x)   BYTEn(x,  1)         // byte 1 (counting from 0)
#define BYTE2(x)   BYTEn(x,  2)

struct RMdlPackedVertexPosition
{
	uint32_t _Value[2];

	Math::Vector3 Unpack()
	{
		float x, y, z;

		x = ((_Value[0] & 0x1FFFFF) * 0.0009765625) - 1024.0;
		y = ((((_Value[1] & 0x3FFu) << 11) + (_Value[0] >> 21)) * 0.0009765625) - 1024.0;
		z = ((_Value[1] >> 10) * 0.0009765625) - 2048.0;

		return Math::Vector3(x, y, z);
	}
};

struct RMdlPackedVertexTBN
{
	uint32_t _Value;

	// uint32_t _Value = 0b11011111111111111111110000110010;
	//                     ^
	//        binorm sign==|^^
	//norm dropped component||^
	//             norm sign==|^^^^^^^^^
	//                           norm1  ^^^^^^^^^
	//                                    norm2  ^^^^^^^^^^
	//                                           packedTangent

	Math::Vector3 UnpackNormal()
	{
		float x, y, z;

		float v87 = ((2 * _Value) >> 30);
		int v88 = 255;
		if (((8 * _Value) >> 31) != 0.0)
			v88 = -255;
		float v89 = (float)v88;
		float v90 = ((_Value << 13) >> 23) + -256.0;
		float v91 = ((16 * _Value) >> 23) + -256.0;
		float v92 = ((v91 * v91) + (255.0 * 255.0)) + (v90 * v90);

		float v93 = sqrtf(v92);
		int v97 = 0;

		float v1, v2, v3;

		v1 = v90 * (1.0 / v93);
		v2 = v89 * (1.0 / v93);
		v3 = v91 * (1.0 / v93);
		if (v87 == 1.0)
			v97 = -1;
		else
			v97 = 0;
		if (v87 == 2.0)
		{
			x = v3;
			y = v1;
			z = v2;
		}
		else
		{
			x = v2;
			y = v3;
			z = v1;
		}
		if (!v97)
		{
			v1 = x;
			v2 = y;
			v3 = z;
		}
		return Math::Vector3(v1, v2, v3);
	}

	Math::Vector3 UnpackTangent(Math::Vector3 Normal)
	{
		float r2y = 1 + Normal.Z;
		r2y = 1.f / r2y;
		float r2z = -r2y * Normal.X;
		float r2w = Normal.Y * Normal.Y;
		float r3x = r2z * Normal.Y;
		float r4x = -r2y * r2w + 1;
		float r4y = -Normal.X;
		float r4z = -Normal.Y;
		float r3z = r2z * Normal.X + 1;
		float r3y;
		float r3w = r4y;
		if (Normal.Z < -0.999899983)
		{
			r2y = 0;
			r2z = -1;
			r2w = 0;
		}
		else
		{
			r2y = r3z;
			r2z = r3x;
			r2w = r3w;
		}
		float r4w = r3x;
		if (Normal.Z < -0.999899983)
		{
			r3x = -1;
			r3y = 0;
			r3z = 0;
		}
		else
		{
			r3x = r4w;
			r3y = r4x;
			r3z = r4z;
		}

		float x = (_Value & 1023) * 0.00614192151;
		float r2x = sin(x);
		r4x = cos(x);
		r3x *= r2x;
		r3y *= r2x;
		r3z *= r2x;
		r2x = r2y * r4x + r3x;
		r2y = r2z * r4x + r3y;
		r2z = r2w * r4x + r3z;

		// normalizing
		float r1w = r2x * r2x + r2y * r2y + r2z * r2z;
		r1w = 1.f / sqrt(r1w);
		r2x *= r1w;
		r2y *= r1w;
		r2z *= r1w;

		return Math::Vector3(r2x, r2y, r2z);
	}

	int8_t GetBitangentSign()
	{
		return _Value >> 31 ? -1 : 1;
	}
};

struct RMdlPackedVertexWeights
{
	uint16_t BlendWeights[2];
	uint8_t BlendIds[4];
};

struct RMdlVGExternalWeights
{
	union
	{
		struct
		{
			uint16_t Weights[4];
			uint32_t Unknown;
		};

		float SimpleWeights[3];
	};

	uint8_t WeightIds[3];
	uint8_t NumWeights;
};

struct RMdlFixup
{
	uint32_t LodIndex;

	uint32_t VertexIndex;
	uint32_t VertexCount;
};

struct RMdlVertex
{
	union
	{
		struct
		{
			uint16_t Weights[4];
			uint32_t WeightTableIndex;
		};

		float SimpleWeights[3];
	};

	uint8_t WeightIds[3];
	uint8_t NumWeights;

	Math::Vector3 Position;
	Math::Vector3 Normal;
	Math::Vector2 UVs;
};

struct mstudiobodyparts_short_t
{
	uint32_t nummodels;
	uint32_t modelindex;
};

struct mstudiobodyparts_t
{
	int sznameindex;
	int nummodels;
	int base;
	int modelindex;
};

struct mstudiobonev54_t
{
	int sznameindex;

	int parent; // parent bone
	int bonecontroller[6]; // bone controller index, -1 == none

	// default values
	Vector3 pos;
	Math::Quaternion quat;
	Math::Vector3 rot; // radianeuler

	Vector3 scale; // bone scale(?)

	matrix3x4_t poseToBone;
	Math::Quaternion qAlignment;

	int flags;
	int proctype;
	int procindex; // procedural rule
	int physicsbone; // index into physically simulated bone

	int surfacepropidx; // index into string tablefor property name

	int contents; // See BSPFlags.h for the contents flags

	int unk; // similar value in studiohdr

	int surfacepropLookup; // unsure, the normal spot has data though

	int unkid; // id is for unk section after stringblock, lacks toggle

	inline void ConstructFromV16(mstudiobone_t_v16& bone, mstudiobonedata_t_v16& data)
	{
		this->sznameindex = FIX_OFFSET(bone.sznameindex);
		this->parent = data.parent;
		this->pos = data.pos;
		this->quat = data.quat;
		this->rot = data.rot;
		this->scale = data.scale;
		this->poseToBone = data.poseToBone;
		this->qAlignment = data.qAlignment;
		this->flags = data.flags;
		this->proctype = data.proctype;
		this->procindex = FIX_OFFSET(data.procindex);
		this->physicsbone = bone.physicsbone;
		this->surfacepropidx = FIX_OFFSET(bone.surfacepropidx);
		this->contents = bone.contents;
		this->surfacepropLookup = bone.surfacepropLookup;
		this->unkid = data.unkid;
	}
};

struct mstudiobonev54_t_v121
{
	int sznameindex;

	int parent; // parent bone
	int bonecontroller[6]; // bone controller index, -1 == none

	// default values
	Vector3 pos;
	Math::Quaternion quat;
	Math::Vector3 rot;
	Vector3 scale; // bone scale(?)

	matrix3x4_t poseToBone;
	Math::Quaternion qAlignment;

	int flags;
	int proctype;
	int procindex; // procedural rule
	int physicsbone; // index into physically simulated bone

	int surfacepropidx; // index into string tablefor property name

	int contents; // See BSPFlags.h for the contents flags

	int surfacepropLookup; // written on compile in v54

	byte unkid; // this is separate because it's set to 0xFF when unused (-1)

	byte unk1[3]; // maybe this is 'unk'?

	inline mstudiobonev54_t Downgrade()
	{
		mstudiobonev54_t out{};
		out.sznameindex = this->sznameindex;

		out.parent = this->parent;
		for (int i = 0; i < 6; i++)
			out.bonecontroller[i] = this->bonecontroller[i];

		out.pos = this->pos;
		out.quat = this->quat;
		out.rot = this->rot;
		out.scale = this->scale;
		out.poseToBone = this->poseToBone;
		out.qAlignment = this->qAlignment;
		out.flags = this->flags;
		out.proctype = this->proctype;
		out.procindex = this->procindex;
		out.physicsbone = this->physicsbone;
		out.surfacepropidx = this->surfacepropidx;
		out.contents = this->contents;
		out.unk = this->unk1[0];
		out.surfacepropLookup = this->surfacepropLookup;
		out.unkid = this->unkid;

		return out;
	}
};

#define JIGGLE_IS_FLEXIBLE				0x01
#define JIGGLE_IS_RIGID					0x02
#define JIGGLE_HAS_YAW_CONSTRAINT		0x04
#define JIGGLE_HAS_PITCH_CONSTRAINT		0x08
#define JIGGLE_HAS_ANGLE_CONSTRAINT		0x10
#define JIGGLE_HAS_LENGTH_CONSTRAINT	0x20
#define JIGGLE_HAS_BASE_SPRING			0x40

struct mstudiojigglebonev54_t
{
	int8_t flags; // looks to be.

	uint8_t bone; // id of bone, might be single byte

	short pad; // possibly unused

	// general params
	float length; // how far from bone base, along bone, is tip
	float tipMass;

	float unkfloat; // v54 adds an extra value here but otherwise the same
	// observed values are between 0-1

	// flexible params
	float yawStiffness;
	float yawDamping;
	float pitchStiffness;
	float pitchDamping;
	float alongStiffness;
	float alongDamping;

	// angle constraint
	float angleLimit; // maximum deflection of tip in radians

	// yaw constraint
	float minYaw; // in radians
	float maxYaw; // in radians
	float yawFriction;
	float yawBounce;

	// pitch constraint
	float minPitch; // in radians
	float maxPitch; // in radians
	float pitchFriction;
	float pitchBounce;

	// base spring
	float baseMass;
	float baseStiffness;
	float baseDamping;
	float baseMinLeft;
	float baseMaxLeft;
	float baseLeftFriction;
	float baseMinUp;
	float baseMaxUp;
	float baseUpFriction;
	float baseMinForward;
	float baseMaxForward;
	float baseForwardFriction;
};

struct mstudioattachmentv54_t
{
	int sznameindex;
	int	flags;

	int	localbone; // parent bone

	matrix3x4_t	localmatrix; // attachment point
};

struct mstudioattachmentv54_t_v16
{
	short sznameindex;
	short localbone; // parent bone
	int flags;

	matrix3x4_t	localmatrix; // attachment point

	inline mstudioattachmentv54_t Downgrade()
	{
		mstudioattachmentv54_t out{};
		out.sznameindex = this->sznameindex;
		out.localbone = this->localbone;
		out.flags = this->flags;
		out.localmatrix = this->localmatrix;
		return out;
	}
};

// $hboxset, $hbox
struct mstudiohitboxset_t
{
	int sznameindex;
	int numhitboxes;
	int hitboxindex;
};

struct mstudiobboxv54_t
{
	int bone = 0;
	int group = 0; // intersection group

	Vector3 bbmin{}; // bounding box
	Vector3 bbmax{};

	int szhitboxnameindex = 0; // offset to the name of the hitbox.

	int unk = 0;
	int keyvalueindex = 0; // used for KV names in string block, should be set to hitboxname if kv unneeded.
};

struct mstudiohitboxset_t_v16
{
	short sznameindex;
	short numhitboxes;
	short hitboxindex;

	inline mstudiohitboxset_t Downgrade()
	{
		return mstudiohitboxset_t{ this->sznameindex, this->numhitboxes, this->hitboxindex};
	}
};


struct mstudiobboxv54_t_v16
{
	short bone;
	short group; // intersection group

	Vector3 bbmin; // bounding box
	Vector3 bbmax;

	uint16_t szhitboxnameindex; // offset to the name of the hitbox.
	uint16_t keyvalueindex; // used for keyvalues, most for titans.

	inline mstudiobboxv54_t Downgrade()
	{
		return mstudiobboxv54_t{ this->bone, this->group, this->bbmin , this->bbmax , this->szhitboxnameindex , 0 , this->keyvalueindex };
	}
};


struct RMdlModel
{
	uint32_t NumLods;
	uint32_t LodOffset;
};

struct RMdlTitanfallModel
{
	char Name[0x40];

	int type;
	float boundingradius;

	int nummeshes;
	int meshindex;
	int numvertices;
	int vertexindex;
	int tangentsindex;

	int numattachments;
	int attachmentindex;

	// might be cut
	int numeyeballs;
	int eyeballindex;

	//mstudio_modelvertexdata_t vertexdata;

	int unk[4];

	int unkindex;
	int unkindex1;

	int unused[4];
};

struct RMdlLod
{
	uint32_t SubmeshCount;
	uint32_t SubmeshOffset;
	float Distance;
};

struct RMdlSubmesh
{
	uint32_t NumStripGroups;
	uint32_t StripGroupOffset;

	uint8_t Flags;
};

struct RMdlStripGroup
{
	uint32_t VertexCount;
	uint32_t VertexOffset;

	uint32_t IndexCount;
	uint32_t IndexOffset;

	uint32_t NumStrips;
	uint32_t StripOffset;

	uint8_t Flags;

	int numTopologyIndices;
	uint32_t topologyOffset;
};

struct RMdlStrip
{
	uint32_t IndexCount;
	uint32_t IndexOffset;

	uint32_t VertexCount;
	uint32_t VertexOffset;

	uint16_t NumBones;

	uint8_t StripFlags;

	uint32_t NumBoneChanges;
	uint32_t BoneChangeOffset;
};

struct RMdlStripVert
{
	uint8_t BoneWeightIndex[3];
	uint8_t NumBones;

	uint16_t VertexIndex;

	uint8_t BoneIds[3];
};

struct RMdlExtendedWeight
{
	uint16_t Weight;
	uint16_t BoneId;
};

struct mstudio_meshvertexdata_t
{
	int unk;
	int numLODVertexes[8];
};

struct mstudiomesh_s3_t
{
	int material;

	int modelindex;

	int numvertices; // number of unique vertices/normals/texcoords
	int vertexoffset; // vertex mstudiovertex_t

	// Access thin/fat mesh vertex data (only one will return a non-NULL result)

	int numflexes; // vertex animation
	int flexindex;

	// special codes for material operations
	int materialtype;
	int materialparam;

	// a unique ordinal for this mesh
	int meshid;

	Vector3 center;

	mstudio_meshvertexdata_t vertexdata;

	int unused[2];
};

struct mstudiomesh_v121_t
{
	int material;

	int modelindex;

	int numvertices; // number of unique vertices/normals/texcoords
	int vertexoffset; // vertex mstudiovertex_t

	// a unique ordinal for this mesh
	int meshid;

	Vector3 center;

	// a unique ordinal for this mesh
	//int meshid;

	mstudio_meshvertexdata_t vertexdata;

	int unused[2];
};

struct mstudiomesh_t_v16
{
	short material;

	// a unique ordinal for this mesh
	short meshid;

	//short modelindex;

	byte unk[4];

	//short numvertices; // number of unique vertices/normals/texcoords
	//short vertexoffset; // vertex mstudiovertex_t

	Vector3 center;
};

struct mstudiobodyparts_t_v15
{
	int sznameindex;
	int nummodels;
	int base;
	int modelindex; // index into models array

	int unk;
	int meshindex; // start of meshes?

	inline mstudiobodyparts_t Downgrade()
	{
		mstudiobodyparts_t out{};
		out.base = this->base;
		out.modelindex = this->modelindex;
		out.nummodels = this->nummodels;
		out.sznameindex = FIX_OFFSET(this->sznameindex);
		return out;
	}
};

struct mstudiobodyparts_t_v16
{
	short sznameindex;
	uint16 modelindex;
	int base;
	int nummodels;
	int meshindex; // index into models array

	inline mstudiobodyparts_t Downgrade()
	{
		mstudiobodyparts_t out{};
		out.base = this->base;
		out.modelindex = this->modelindex;
		out.nummodels = this->nummodels;
		out.sznameindex = FIX_OFFSET(this->sznameindex);
		return out;
	}
};

struct RMdlTitanfallLodSubmesh
{
	uint32_t Index;

	uint16_t Unknown1;
	uint16_t Unknown2;
	uint16_t Unknown3;
	uint16_t Unknown4;

	uint8_t UnknownPad[0x28];

	uint32_t LodVertCounts[8];

	uint8_t UnknownPad2[0x20];
};

struct mstudiotexturev54_t
{
	int sznameindex;
	uint64_t guid;
};

// fake studio struct
struct mstudiomaterial_t
{
	uint64_t guid;
	string name;

};

struct mstudiotexturev54_t_v16
{
	uint64_t guid;

	inline mstudiotexturev54_t Downgrade()
	{
		return mstudiotexturev54_t{ 0, guid };
	}
};
#pragma pack(pop)

// Game helper structs
struct RMdlFixupPatches
{
	List<mstudiomaterial_t>* Materials;
	List<uint8_t>* BoneRemaps;
	string MaterialPath;

	uint64_t VertexShift;
	uint64_t MeshOffset;
	uint64_t WeightsTableOffset;
};

struct RMdlMaterial
{
	uint8_t MaterialType;
	string MaterialName;
	string FullMaterialName; // made another var so i dont break things somehow

	string AlbedoMapName;
	string NormalMapName;
	string GlossMapName;
	string SpecularMapName;
	string EmissiveMapName;
	string AmbientOcclusionMapName;
	string CavityMapName;

	uint64_t AlbedoHash;
	uint64_t NormalHash;
	uint64_t GlossHash;
	uint64_t SpecularHash;
	uint64_t EmissiveHash;
	uint64_t AmbientOcclusionHash;
	uint64_t CavityHash;
};

//ASSERT_SIZE(mstudiobone_t, 0xB4);
//ASSERT_SIZE(RMdlMeshStreamHeader, 0x24);
//ASSERT_SIZE(vertexFileHeader_t, 0x40);
//ASSERT_SIZE(RMdlFixup, 0xC);
//ASSERT_SIZE(RMdlVertex, 0x30);
//ASSERT_SIZE(mstudiobodyparts_short_t, 0x8);
//ASSERT_SIZE(RMdlModel, 0x8);
//ASSERT_SIZE(RMdlLod, 0xC);
//ASSERT_SIZE(RMdlSubmesh, 0x9);
//ASSERT_SIZE(RMdlStripGroup, 0x19);
//ASSERT_SIZE(RMdlStripVert, 0x9);
//ASSERT_SIZE(RMdlStrip, 0x1B);
//ASSERT_SIZE(RMdlExtendedWeight, 0x4);
//ASSERT_SIZE(RMdlTexture, 0xC);